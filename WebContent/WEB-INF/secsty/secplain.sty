% Copyright: (c) 2007 The Open University, Milton Keynes, UK.
% Based upon Don Knuth's plain.tex.
% License: GPL version 2 or (at your option) any later version.
% Author: Jonathan Fine <jfine@pytex.org>, <J.Fine@open.ac.uk>
% $Source$
% $Revision: 136 $ $Date: 2009-03-10 21:12:28 +0100 (Tue, 10 Mar 2009) $
% With corrections from Ganesan Venkatasubramanian (r118, r132).

% TODO: Make ~ active.
% TODO: Backslash before \rightarrow, \leftarrow?
% TODO: Set pageno to 1.
% TODO: Allow user-space if commands?
% TODO: Remove bmath and emath.
% TODO: Initialise \time, \day, \month and \year (from Python)

% User commands begin with a backslash.  User commands should never
% call user commands.

% System commands begin with a letter (and in reality are prefixed
% with an underscore).  System commands should call only system
% commands.


\input secmove.sty
\_input seccode.sty

\_code

    catcode `'{ 1
    catcode `'} 2

    catcode `!& 13
    let !& &
    let bmath |324
    let emath |324

    let sup |75E
    let sub |85F
    let align.tab &

    def plus {"plus"}
    def minus {"minus"}
    def height {"height"}
    def depth {"depth"}
    def width {"width"}
    def to {"to"}
    def in {"in"}
    def fil {"fil"}
    def mu {"mu"}


    def secure_vbox
    {
        scrollmode
        shipout vbox bgroup
            begingroup
              catcode `\_ 12
              catcode 0~ 13~
              catcode `\$ 13~
              catcode `\^ 13~
              catcode `\_ 13~
              let !$ |324
              let !^ |75E
              let !_ |85F
              global pageno num_1
              hsize "4in "
    }

    def secure_hbox
    {
        scrollmode
        setbox 0 hbox bgroup
            aftergroup finish_secure_hbox
            begingroup
              catcode `\_ 12
              catcode 0~ 13~
              catcode `\$ 13~
              catcode `\^ 13~
              catcode `\_ 13~
              let !$ |324
              let !^ |75E
              let !_ |85F
              global pageno num_1
    }

    def finish_secure_hbox 
    {
      ht 0~ 0 "pt "
      shipout box 0~      
    }

    outer def |D00
    {
      par
      endgroup
      egroup
    }

Primitives that are accessible in plain.
    let \left left
    let \right right
    let \over over
    let \cr cr
    let \  ex_space
    let \displaystyle displaystyle
    let \textstyle textstyle
    let \scriptstyle scriptstyle
    let \scriptscriptstyle scriptscriptstyle
    let \hfil hfil
    let \eqno eqno
    let \leqno leqno
    let \limits limits
    let \nolimits nolimits
    let \omit omit
    let \span span
    let \atop atop
    let \overline overline
    let \underline underline
    let \hbox hbox
    let \\ cr

Stopgap until we get secure LaTeX.
    def \frac #1 #2
    {{begingroup #1 endgroup over begingroup #2 endgroup}}

    def \dfrac #1 #2
    {{displaystyle {begingroup #1 endgroup over begingroup #2 endgroup}}}

    def \tfrac #1 #2
    {{
        textstyle 
        {begingroup #1 endgroup over begingroup #2 endgroup}
    }}

    def \pounds { hbox { it '$ }}

do.specials.

    mathcode 00 @hex{2201} % \cdot
    mathcode 01 @hex{3223} % \downarrow
    mathcode 02 @hex{010B} % \alpha
    mathcode 03 @hex{010C} % \beta
    mathcode 04 @hex{225E} % \land
    mathcode 05 @hex{023A} % \lnot
    mathcode 06 @hex{3232} % \in
    mathcode 07 @hex{0119} % \pi
    mathcode 08 @hex{0115} % \lambda
    mathcode 09 @hex{010D} % \gamma
    mathcode 10 @hex{010E} % \delta
    mathcode 11 @hex{3222} % \uparrow
    mathcode 12 @hex{2206} % \pm
    mathcode 13 @hex{2208} % \oplus
    mathcode 14 @hex{0231} % \infty
    mathcode 15 @hex{0140} % \partial
    mathcode 16 @hex{321A} % \subset
    mathcode 17 @hex{321B} % \supset
    mathcode 18 @hex{225C} % \cap
    mathcode 19 @hex{225B} % \cup
    mathcode 20 @hex{0238} % \forall
    mathcode 21 @hex{0239} % \exists
    mathcode 22 @hex{220A} % \otimes
    mathcode 23 @hex{3224} % \leftrightarrow
    mathcode 24 @hex{3220} % \leftarrow
    mathcode 25 @hex{3221} % \rightarrow
    mathcode 26 @hex{8000} % \ne
    mathcode 27 @hex{2205} % \diamond
    mathcode 28 @hex{3214} % \le
    mathcode 29 @hex{3215} % \ge
    mathcode 30 @hex{3211} % \equiv
    mathcode 31 @hex{225F} % \lor
    mathcode `\  @hex{8000} % \space
    mathcode `\! @hex{5021}
    mathcode `\' @hex{8000} % ^\prime
    mathcode `\( @hex{4028}
    mathcode `\) @hex{5029}
    mathcode `\* @hex{2203} % \ast
    mathcode `\+ @hex{202B}
    mathcode `\, @hex{613B}
    mathcode `\- @hex{2200}
    mathcode `\. @hex{013A}
    mathcode `\/ @hex{013D}
    mathcode `\: @hex{303A}
    mathcode `\; @hex{603B}
    mathcode `\< @hex{313C}
    mathcode `\= @hex{303D}
    mathcode `\> @hex{313E}
    mathcode `\? @hex{503F}
    mathcode `\[ @hex{405B}
    mathcode `\\ @hex{026E} % \backslash
    mathcode `\] @hex{505D}
    mathcode `\_ @hex{8000} % \_
    mathcode `\{ @hex{4266}
    mathcode `\| @hex{026A}
    mathcode `\} @hex{5267}
    mathcode 127 @hex{1273} % \smallint

    sfcode`\) 0; sfcode`\' 0; sfcode`\] 0

    delcode`\( @hex{028300}
    delcode`\) @hex{029301}
    delcode`\[ @hex{05B302}
    delcode`\] @hex{05D303}
    delcode`\< @hex{26830A}
    delcode`\> @hex{26930B}
    delcode`\/ @hex{02F30E}
    delcode`\| @hex{26A30C}
    delcode`\\ @hex{26E30F}

Plain does not use \thr@@.
    chardef zero 0
    chardef num_1 1
    chardef num_2 2
    chardef num_3 3
    chardef num_16 16
    chardef num_255 255
    mathchardef num_256 256
    mathchardef num_1000 1000
    mathchardef num_10000 10000
    mathchardef num_20000 20000

    count 10~ 22~               % Allocates \count registers 23, 24, ...
    count 11~ 9~                % allocates \dimen registers 10, 11, ...
    count 12~ 9~                % allocates \skip registers 10, 11, ...
    count 13~ 9~                % allocates \muskip registers 10, 11, ...
    count 14~ 9~                % allocates \box registers 10, 11, ...
    count 15~ 9~                % allocates \toks registers 10, 11, ...
    count 16~ -1~               % allocates input streams 0, 1, ...
    count 17~ -1~               % allocates output streams 0, 1, ...
    count 18~ 3~                % allocates math families 4, 5, ...
    count 19~ 0~                % allocates \language codes 1, 2, ...
    count 20~ 255~              % allocates insertions 254, 253, ...
    countdef insert.count 20~   % the insertion counter
    countdef alloc.last 21~     % the most recent allocation
    countdef minus_1 22~; minus_1 -1~ % a handy constant

    def log { immediate write num_16 }

    countdef count.tmp 255~
    dimendef dimen.tmp 0~
    dimendef dimen.tmp1 1~
    dimendef dimen.tmp2 2~
    skipdef skip.tmp 0~
    muskipdef muskip.tmp 0~
    toksdef toks.tmp 0~

We don't provide \newhelp.
    def newcount { alloc 0 count countdef insert.count }
    def newdimen { alloc 1 dimen dimendef insert.count }
    def newskip { alloc 2 skip skipdef insert.count }
    def newmuskip { alloc 3 muskip muskipdef num_256 }
    def newbox { alloc 4 box chardef insert.count }
    def newtoks { alloc 5 toks toksdef num_256 }
    def newread { alloc 6 read chardef num_16 }
    def newwrite { alloc 7 write chardef num_16 }
    def newfam { alloc 8 fam chardef num_16 }
    def newlanguage { alloc 9 write chardef num_256 }


    def alloc #1 #2 #3 #4 #5
    {
        global advance count 1#1~ num_1
        alloc.check #1 #4 #2;   % Make sure there's still room.
        alloc.last count 1#1
        global #3 #5 alloc.last
        log{string #5 = string #2 the alloc.last}
    }

    def newinsert #1
    {
        global advance insert.count minus_1
        alloc.check 0 insert.count count
        alloc.check 1 insert.count dimen
        alloc.check 2 insert.count skip
        alloc.check 4 insert.count box

        alloc.last = insert.count
        global chardef #1 alloc.last
        log{string #1 = string insert the alloc.last}
    }

    def alloc.check #1 #2  #3
    {
        ifnum count 1#1 < #2 else
            errmessage{"No room for a new " #3}
        fi
    }

    newdimen maxdimen;  maxdimen "16383.99999pt "
    newskip hideskip; hideskip "-1000pt plus 1fill "
    newskip centering; centering "0pt plus 1000pt minus 1000pt "
    newdimen pt; pt "1pt "
    newdimen zero zero "0pt"
    newskip zero.skip; zero.skip "0pt plus0pt minus0pt"
    newbox void_box

    def csarg #1
    {
        begingroup
            escapechar minus_1
            expandafter
        endgroup
        expandafter #1
        csname
    }

    def newif #1
    {
        csarg def newif_1 #1 "true" endcsname {let #1 iftrue}
        csarg def newif_1 #1 "false" endcsname {let #1 iffalse }
        csarg relax newif_1 #1 "false" endcsname
    }

    def newif_1 #1 { expandafter newif_2 string #1 }
    def newif_2 "_if" { "_" }

    pretolerance 100
    tolerance 200
    hbadness 1000
    vbadness 1000
    linepenalty 10
    hyphenpenalty 50
    exhyphenpenalty 50
    binoppenalty 700
    relpenalty 500
    clubpenalty 150
    widowpenalty 150
    displaywidowpenalty 50
    brokenpenalty 100
    predisplaypenalty 10000
    doublehyphendemerits 10000
    finalhyphendemerits 5000
    adjdemerits 10000
    tracinglostchars 1
    uchyph 1
    lefthyphenmin 2
    righthyphenmin 3
    defaulthyphenchar `\-
    defaultskewchar -1
    newlinechar -1
    delimiterfactor 901
    showboxbreadth 5
    showboxdepth 3
    errorcontextlines 5


    hfuzz 0.1pt
    vfuzz 0.1pt
    overfullrule 5pt
    hsize 6.5in
    vsize 8.9in
    maxdepth 4pt
    splitmaxdepth maxdimen
    boxmaxdepth maxdimen
    delimitershortfall 5pt
    nulldelimiterspace 1.2pt
    scriptspace 0.5pt
    parindent 20pt
    parskip 0pt plus 1pt
    abovedisplayskip 12pt plus 3pt minus 9pt
    abovedisplayshortskip 0pt plus 3pt
    belowdisplayskip 12pt plus 3pt minus 9pt
    belowdisplayshortskip 7pt plus 3pt minus 4pt
    topskip 10pt
    splittopskip 10pt
    parfillskip 0pt plus 1fil

    thinmuskip 3mu
    medmuskip 4mu plus 2mu minus 4mu
    thickmuskip 5mu plus 5mu

    newskip smallskipamount; smallskipamount "3pt plus 1pt minus 1pt "
    newskip medskipamount; medskipamount "6pt plus 2pt minus 2pt "
    newskip bigskipamount; bigskipamount "12pt plus 4pt minus 4pt "
    newskip normalbaselineskip; normalbaselineskip "12pt "
    newskip normallineskip; normallineskip "1pt "
    newdimen normallineskiplimit; normallineskiplimit "0pt "
    newdimen jot; jot "3pt "
    newcount interdisplaylinepenalty; interdisplaylinepenalty 100
    newcount interfootnotelinepenalty; interfootnotelinepenalty 100

Some trickiness here with optional spaces.
    def magstephalf {"1095 "}
    def magstep #1
    {
        ifcase #1 ~
            1000 or 1200 or 1440 or 1200 or 1440 or 1728 or 2074 or 2488
        fi ~
    }

    font cmr5 "cmr5 "
    font cmr6 "cmr6 "
    font cmr7 "cmr7 "
    font cmr8 "cmr8 "
    font cmr9 "cmr9 "
    font cmr10 "cmr10 "

    font cmmi5 "cmmi5 "
    font cmmi6 "cmmi6 "
    font cmmi7 "cmmi7 "
    font cmmi8 "cmmi8 "
    font cmmi9 "cmmi9 "
    font cmmi10 "cmmi10 "

    font cmsy5 "cmsy5 "
    font cmsy6 "cmsy6 "
    font cmsy7 "cmsy7 "
    font cmsy8 "cmsy8 "
    font cmsy9 "cmsy9 "
    font cmsy10 "cmsy10 "

    font cmex10 "cmex10 "

    font cmss10 "cmss10 "
    font cmssq8 "cmssq8 "

    font cmssi10 "cmssi10 "
    font cmssqi8 "cmssqi8 "

    font cmbx5 "cmbx5 "
    font cmbx6 "cmbx6 "
    font cmbx7 "cmbx7 "
    font cmbx8 "cmbx8 "
    font cmbx9 "cmbx9 "
    font cmbx10 "cmbx10 "

    font cmtt8 "cmtt8 "
    font cmtt9 "cmtt9 "
    font cmtt10 "cmtt10 "
    font cmsltt10 "cmsltt10 "

    font cmsl8 "cmsl8"
    font cmsl9 "cmsl9"
    font cmsl10 "cmsl10"

    font cmti7 "cmti7 "
    font cmti8 "cmti8 "
    font cmti9 "cmti9 "
    font cmti10 "cmti10 "

\message{more fonts,}
\font\preloaded=cmu10 % unslanted text italic

\font\preloaded=cmmib10 % bold math italic
\font\preloaded=cmbsy10 % bold math symbols

\font\preloaded=cmcsc10 % caps and small caps

\font\preloaded=cmssbx10 % sans serif bold extended

\font\preloaded=cmdunh10 % Dunhill style

\font\preloaded=cmr7 scaled \magstep4 % for titles
\font\preloaded=cmtt10 scaled \magstep2
\font\preloaded=cmssbx10 scaled \magstep2

\font\preloaded=manfnt % METAFONT logo and dragon curve and special symbols

Double '' due to semantics of '.
    skewchar cmmi5 ''177
    skewchar cmmi6 ''177
    skewchar cmmi7 ''177
    skewchar cmmi8 ''177
    skewchar cmmi9 ''177
    skewchar cmmi10 ''177

    skewchar cmsy5 ''60
    skewchar cmsy6 ''60
    skewchar cmsy7 ''60
    skewchar cmsy8 ''60
    skewchar cmsy9 ''60
    skewchar cmsy10 ''60

    textfont 0 cmr10
    scriptfont 0 cmr7
    scriptscriptfont 0 cmr5
    def \rm { fam 0~; cmr10 }

    textfont 1 cmmi10
    scriptfont 1 cmmi7
    scriptscriptfont 1 cmmi5
    def \mit { fam 1~ }
    def \oldstyle { fam 1~; cmmi10 }

    textfont 2 cmsy10
    scriptfont 2 cmsy7
    scriptscriptfont 2 cmsy5
    def \cal { fam 2~ }

    textfont 3 cmex10
    scriptfont 3 cmex10
    scriptscriptfont 3 cmex10
    
    def it { fam 4~; cmti10 }
    textfont 4~ cmti10
    let \it it

    def \sl { fam 5~; cmsl10 }
    textfont 5~ cmsl10

    def \bf { fam 6~; cmbx10 }
    textfont 6~ cmbx10
    scriptfont 6~ cmbx7
    scriptscriptfont 6~ cmbx5

    def \tt { fam 7~; cmtt10 }
    textfont 7~ cmtt10

    def \mathbf {\bf}
    def \mathcal {\cal}
    def \mathtt {\tt}

5.  Macros for text.

    def frenchspacing
    {
        sfcode `\. num_1000; sfcode `\? num_1000; sfcode `\! num_1000
        sfcode `\: num_1000; sfcode `\; num_1000; sfcode `\, num_1000
    }

The trailing space is to avoid a weird error.
    def nonfrenchspacing
    {
        sfcode `\. 3000; sfcode `\? 3000; sfcode `\! 3000
        sfcode `\: 2000; sfcode `\; 1500; sfcode `\, 1250~
    }

    def normalbaselines
    {
      lineskip normallineskip
      baselineskip normalbaselineskip
      lineskiplimit normallineskiplimit
    }

    def |00D {|020}             % control <return> = control <space>
    def |009 {|020}             % same for <tab>

    def empty {}
    def null {hbox{}}

    let bgroup {; let egroup }

We drop \obeylines and \obeyspaces, because they change catcodes.

Command \loop is used by \multispan.
    def loop #1 repeat { def loop.body {#1}; loop.iterate }
    def loop.iterate
    {
        body;                   % The \body starts with an \if command.
          let next iterate
        else let next relax fi
        next
    }
    let repeat fi               % this makes \loop...\if...\repeat skippable

    def \thinspace {kern ".16667em " }
    def \negthinspace{kern "-.16667em " }
    def \enspace {kern ".5em " }

    def \enskip {hskip ".5em" relax}
    def quad {hskip "1em" relax}
    let \quad quad
    def \qquad {hskip "2em" relax}

    def \smallskip {vskip smallskipamount}
    def \medskip {vskip medskipamount}
    def \bigskip {vskip bigskipamount}

    def nointerlineskip {prevdepth -1000pt}
    def offinterlineskip
    {
        baselineskip -1000pt
        lineskip zero
        lineskiplimit maxdimen
    }

    def topglue {nointerlineskip; vglue -topskip; vglue}

Do we want the trailing '=', which is in plain.tex?
    def vglue{afterassignment vglue_1; skip.tmp =}
    def vglue_1
    {
        par
        dimen.tmp prevdepth
        hrule height zero; nobreak; vskip skip.tmp
        prevdepth dimen.tmp
    }

    def hglue {afterassignment hglue_1; skip.tmp =}
    def hglue_1
    {
        leavevmode
        count.tmp spacefactor
        vrule width zero; nobreak; hskip skip.tmp
        spacefactor count.tmp
    }

    def !~ {penalty num_1000} % tie
    def \slash {"/"; penalty exhyphenpenalty}

    def \break {penalty -num_1000}
    def \nobreak {penalty  -num_1000}
    def \allowbreak {penalty zero}

    def \filbreak {par; vfil; penalty -200; vfilneg}
    def \goodbreak {par;  penalty -500~}
    def \eject {par; break}
    def \supereject {par; penalty -num_20000}

    def removelastskip {ifdim lastskip=zero else vskip -lastskip fi}

    def smallbreak
    {
        par
        ifdim lastskip < smallskipamount
            removelastskip; penalty -50; smallskip
        fi
    }
    def medbreak
    {
        par
        ifdim lastskip < medskipamount
            removelastskip; penalty -100; smallskip
        fi
    }
    def bigbreak
    {
        par
        ifdim lastskip < bigskipamount
            removelastskip; penalty -200; smallskip
        fi
    }

Note use of 'line' and '\line'.
    def line {hbox to hsize}
    def \line #1 {line{#1}}
    def \leftline #1 {line{#1 hss}}
    def \rightline #1 {line{ hss #1}}
    def \centerline #1 {line{hss #1 hss}}

    def rlap #1 {hbox to zero{#1 hss}}
    def llap #1 {hbox to zero{hss #1}}

    def mathsurround.zero {mathsurround zero}

Note that '$\underbar{x}$' gives a strange error.
    def \underbar #1
    {
        bmath
            setbox zero hbox{#1}; dp zero zero
            mathsurround.zero
            underline {box zero}
        emath
    }

    newbox strutbox
    setbox strutbox hbox{vrule "height 8.5pt depth3.5pt width " zero}
    def strut{ relax; ifmmode copy strutbox else unhcopy strutbox fi}
    let \strut strut

    def hidewidth {hskip hideskip} % for alignment entries that can stick out

I do not like the name 'ialign', and it has side effects.
    def ialign {everycr{}; tabskip zero.skip; halign} % initialized  halign
    newcount mscount
    def \multispan #1
    {
        omit
        mscount #1 relax
        loop ifnum mscount> num_1, multispan_1 repeat
    }
    def multispan_1 {span; omit; advance mscount minus_1}

    newif iftabs.use
    newif iftabs.cr
    newbox tabs
    newbox tabs.yet
    newbox tabs.done

    def \cleartabs {global setbox tabs.yet null; setbox tabs null}
    def \settabs {setbox tabs null; futurelet next settabs_1}

    def settabs_1
    {
        ifx next \+
            def next_1 {afterassignment settabs.sample; let next_1}
        else
            let next_1 settabs.columns
        fi
        let next relax
        next_1
    }

More tabs code, to be converted.
    def settabs.sample {let next_1 relax; tabs.usefalse; tabs.makebox}
    
    def \tabalign {tabs.usetrue; tabs.makebox} % non-\outer version of \+
    outer def \+ {\tabalign}

    def settabs.columns #1 \columns {
        count.tmp #1; dimen.tmp hsize
        loop ifnum count.tmp > zero settabs.another repeat
    }

    def settabs.another {
        dimen.tmp2 dimen.tmp; divide dimen.tmp2 count.tmp
        setbox tabs hbox{hbox to dimen.tmp2{}; unhbox tabs}
        advance dimen.tmp -dimen.tmp2; advance count.tmp minus.one
    }
   
    def tabs.makebox {
        begingroup
            global setbox tabsyet copy tabs
            global setbox tabsdone null
            def cr {
                tabs.crtrue; crcr; egroup; egroup
                iftabs.use unvbox zero; lastbox fi
                endgroup
                setbox tabs hbox{ unhbox tabsyet; unhbox tabsdone}
            }
            setbox zero vbox bgroup tabs.crfalse
                ialign bgroup & tabs.makebox_1 ## tabs.makebox_2 crcr
    }
    
    def tabs.makebox_1 {setbox zero hbox bgroup}
    
    def tabs.makebox_2 { 
        iftabs.cr egroup % now  box z@ holds the column
        else 
            hss; egroup  
            global setbox tabsyet hbox
                {unhbox tabsyet; global setbox num_1 lastbox}% now  box @ne holds its size
            ifvoid num_1
                global setbox num_1 hbox to wd zero{}%
            else 
                setbox zero hbox to wd num_1{unhbox zero} 
            fi
            global setbox tabsdone hbox{box num_1; unhbox tabsdone} 
        fi
        box zero
    }

    def hang {hangindent parindent}
    def textindent #1 {indent; llap{#1; enspace}; ignorespaces}
    def \item {par; hang; textindent}
    def \itemitem {par; indent;  hangindent 2, parindent; textindent}
    def \narrower
    {
        advance leftskip parindent
        advance rightskip parindent
    }

I'm troubled that this can pick up the \par.
    outer def beginsection #1 par
    {
        vskip zero "plus .3" vsize
        penalty -250
        vskip zero "plus -.3" vsize
        bigskip
        vskip parskip
        message{#1};             % This may allow mischief.
        leftline{bf #1}
        nobreak; smallskip; noindent
    }

    outer def proclaim #1 ". " #2 par
    {
        medbreak
        noindent; {bf #1 ". "; enspace}; {sl #2; par}
        ifdim lastskip< medskipamount,
            removelastskip; penalty 55; medskip
        fi
    }

    def raggedright { rightskip zero "plus2em"; spaceskip ".3333em"
        xspaceskip ".5em"; relax}
    def ttraggedright {tt; rightskip zero "plus2em"; relax}

    chardef \% `\%
    chardef \& `\&
    chardef \# `\#
    chardef \$ `\$
    chardef \ss @hex{19}
    chardef \ae @hex{1A}
    chardef \oe @hex{1B}
    chardef \o= @hex{1C}
    chardef \AE @hex{1D}
    chardef \OE @hex{1E}
    chardef \O @hex{1F}
    chardef \i @hex{10}           % Dotless 'i'.
    chardef \j @hex{11}           % Dotless 'j'.
    def \aa {accent 23 "a"}
    def \l {char 32; "l"}
    def \L
    {
        leavevmode
        setbox zero hbox{"L"}
        hbox "to"  wd 0 {hss; char32 "L"}
    }

     def leavevmode {unhbox void_box} % begins a paragraph, if necessary
     def \_ {leavevmode; kern ".06em"; vbox{hrule "width.3em"}}
     def \AA
     {
         leavevmode; setbox0\hbox{"!"}; dimen.tmp ht0
         advance dimen.tmp "-1ex"
         rlap{raise ".67" dimen.tmp hbox{ char ''27}}
         "A"
     }

     def mathhexbox #1 #2 #3 {
         leavevmode
         hbox {
             bmath
                 mathsurround.zero
                 mathchar '" #1#2#3
             emath
         }
     }

    def \dag {mathhexbox "279" }
    def \ddag {mathhexbox "27A" }
    def \S {mathhexbox "278" }
    def \P {mathhexbox "27B" }
    def \Orb {mathhexbox "20D" }

    def oalign #1
    {
        leavevmode
        vtop
        {
            baselineskip zero.skip; lineskip ".25ex"
            ialign{## crcr #1 crcr}
        }
    }

    def oalign_1 {lineskiplimit zero; olaign}
    def ooalign {lineskiplimit -maxdimen; oalign} % chars over each other
    def get.factor #1 "pt" {#1}

    def accent.shift #1 {
        dimen.tmp #1
        kern expandafter get.factor the fontdimen 1 font, dimen.tmp
    }

    def \d #1 {{oalign{
          relax; #1 crcr
          hidewidth; accent.shift{"-1ex"} "."; hidewidth
        }}}
    def \b #1 {{oalign{
          relax; #1; crcr
          hidewidth; accent.shift{"-3ex"}
          vbox "to.2ex"{hbox{char 22}; vss}
          hidewidth
        }}}
    def \c #1 {{
        setbox zero hbox{#1}
        ifdim ht zero = "1ex",
            accent 24 #1
         else
            ooalign{unhbox zero crcr; hidewidth; char 24;  hidewidth}
         fi
    }}
    def \copyright {{ooalign{
          hfil; raise ".07ex"; hbox{"c"}; hfil; crcr
          \Orb
        }}}

    def \dots {
        relax
        ifmmode \ldots
        else
            bmath; mathsurround.zero; \ldots; \,; emath
        fi
    }

    def \TeX {"T"; kern "-.1667em"; lower ".5ex" hbox{"E"}
        kern "-.125em"; "X"}

    def \` #1 {{accent 18 #1}}
    def \' #1 {{accent 19 #1}}
    def \v #1 {{accent 20 #1}}    % \let\^^_=\v
    let |01F \v
    def \u #1 {{accent 21 #1}}    % \let\^^S=\u
    let |013 \u
    def \= #1 {{accent 22 #1}}
    def \^ #1 {{accent 94 #1}}    % \let\^^D=\^
    let |04 \^
    def \. #1 {{accent 95 #1}}
    def \H #1 {{accent @hex{7D} #1}}
    def \~ #1 {{accent @hex{7E} #1}}
    def \" #1 {{accent @hex{7F} #1}}
    def \t #1 {{
        edef next{the font}
        the textfont 1
        accent @hex{7F}; next; #1
    }}

    def hrulefill {leaders hrule hfill}
    def dotfill {
        cleaders hbox{
            bmath
              mathsurround.zero
              mkern "1.5mu"; "."; mkern "1.5mu"
            emath
        }
        hfill
    }

    def rightarrowfill {$
        mathsurround.zero
        smash "-"; mkern "-7mu"
        cleaders hbox{$ mkern "-2mu"; smash "-"; mkern "-2mu" $}, hfill
        mkern "-7mu"; mathord rightarrow
    $}

    def leftarrowfill {$
        mathsurround.zero; mathord leftarrow; mkern "-7mu"
        cleaders hbox{$ mkern "-2mu"; smash "-"; mkern "-2mu" $}, hfill
        mkern "-7mu"; smash "-"
    $}

    mathchardef brace.ld @hex{37A}
    mathchardef brace.rd @hex{37B}
    mathchardef brace.lu @hex{37C}
    mathchardef brace.ru @hex{37D}

    def downbracefill {
        bmath
            mathsurround.zero; setbox zero hbox {bmath; brace.ld; emath}
            brace.ld
            leaders vrule "height" ht zero "depth" zero hfill
            brace.ru; brace.lu
            leaders vrule "height" ht zero "depth" zero hfill
            brace.rd
        emath
    }

Why initialise with brace.ld rather than brace.lu?
    def upbracefill {
        bmath
            mathsurround.zero; setbox zero hbox {bmath; brace.ld; emath}
            brace.lu
            leaders vrule "height" ht zero "depth" zero hfill
            brace.rd; brace.ld
            leaders vrule "height" ht zero "depth" zero hfill
            brace.ru
        emath
    }

Not a user command, until we remove the \end.
    outer def bye { par; vfill; supereject}

6.  Macros for math.

    def \, { mskip thinmuskip }
    def \> { mskip medmuskip }
    def \; { mskip thickmuskip }
    def \! { mskip - thinmuskip }
    def \* { discretionary{ thinspace the textfont 2 char 2 }{}{}}
    
    gdef !' {sup bgroup primes_1}
    def primes_1 {\prime; futurelet next primes_2}
    def primes_2 {
        ifx !' next
            let next_1 primes_3
        else ifx sup next
                 let next_1 primes_sup
             else
                 let next_1 egroup
             fi
        fi
        next_1
    }
    def primes_3 #1 {primes_1}
    def primes_sup #1 #2 {#2; egroup}

    def |D1A {not, "="}        % ^^Z
    let |D5F \_                % _
    
    mathchardef \alpha @hex{010B}
    mathchardef \beta @hex{010C}
    mathchardef \gamma @hex{010D}
    mathchardef \delta @hex{010E}
    mathchardef \epsilon @hex{010F}
    mathchardef \zeta @hex{0110}
    mathchardef \eta @hex{0111}
    mathchardef \theta @hex{0112}
    mathchardef \iota @hex{0113}
    mathchardef \kappa @hex{0114}
    mathchardef \lambda @hex{0115}
    mathchardef \mu @hex{0116}
    mathchardef \nu @hex{0117}
    mathchardef \xi @hex{0118}
    mathchardef \pi @hex{0119}
    mathchardef \rho @hex{011A}
    mathchardef \sigma @hex{011B}
    mathchardef \tau @hex{011C}
    mathchardef \upsilon @hex{011D}
    mathchardef \phi @hex{011E}
    mathchardef \chi @hex{011F}
    mathchardef \psi @hex{0120}
    mathchardef \omega @hex{0121}
    mathchardef \varepsilon @hex{0122}
    mathchardef \vartheta @hex{0123}
    mathchardef \varpi @hex{0124}
    mathchardef \varrho @hex{0125}
    mathchardef \varsigma @hex{0126}
    mathchardef \varphi @hex{0127}
    mathchardef \Gamma @hex{7000}
    mathchardef \Delta @hex{7001}
    mathchardef \Theta @hex{7002}
    mathchardef \Lambda @hex{7003}
    mathchardef \Xi @hex{7004}
    mathchardef \Pi @hex{7005}
    mathchardef \Sigma @hex{7006}
    mathchardef \Upsilon @hex{7007}
    mathchardef \Phi @hex{7008}
    mathchardef \Psi @hex{7009}
    mathchardef \Omega @hex{700A}

    mathchardef \aleph @hex{0240}
    def \hbar {{ mathchar "'26" mkern "-9muh" }}
    mathchardef \imath @hex{017B}
    mathchardef \jmath @hex{017C}
    mathchardef \ell @hex{0160}
    mathchardef \wp @hex{017D}
    mathchardef \Re @hex{023C}
    mathchardef \Im @hex{023D}
    mathchardef \partial @hex{0140}
    mathchardef \infty @hex{0231}
    mathchardef \prime @hex{0230}
    mathchardef \emptyset @hex{023B}
    mathchardef \nabla @hex{0272}
    def \surd {{ mathchar @hex{1270}}}
    mathchardef \top @hex{023E}
    mathchardef \bot @hex{023F}
    def \angle {{
        vbox{ialign{
            bmath; mathsurround.zero; scriptstyle##; emath; crcr
            not; mathrel{ mkern "14mu"} crcr
            noalign{nointerlineskip}
            mkern "2.5mu"
            leaders hrule height ".34"pt hfill
            mkern "2.5mu"
            crcr
        }}
    }}
    mathchardef \triangle @hex{0234}
    mathchardef \forall @hex{0238}
    mathchardef \exists @hex{0239}
    mathchardef \neg @hex{023A}
    let \lnot \neg
    mathchardef \flat @hex{015B}
    mathchardef \natural @hex{015C}
    mathchardef \sharp @hex{015D}
    mathchardef \clubsuit @hex{027C}
    mathchardef \diamondsuit @hex{027D}
    mathchardef \heartsuit @hex{027E}
    mathchardef \spadesuit @hex{027F}

    mathchardef \coprod @hex{1360}
    mathchardef \bigvee @hex{1357}
    mathchardef \bigwedge @hex{1356}
    mathchardef \biguplus @hex{1355}
    mathchardef \bigcap @hex{1354}
    mathchardef \bigcup @hex{1353}
    mathchardef intop @hex{1352}
    def \int {intop, nolimits}
    mathchardef \prod @hex{1351}
    mathchardef \sum @hex{1350}
    mathchardef \bigotimes @hex{134E}
    mathchardef \bigoplus @hex{134C}
    mathchardef \bigodot @hex{134A}
    mathchardef ointop @hex{1348}
    def \oint {ointop, nolimits}
    mathchardef \bigsqcup @hex{1346}
    mathchardef \smallint @hex{1273}

    mathchardef \triangleleft @hex{212F}
    mathchardef \triangleright @hex{212E}
    mathchardef \bigtriangleup @hex{2234}
    mathchardef \bigtriangledown @hex{2235}
    mathchardef \wedge @hex{225E}
    let \land \wedge
    mathchardef \vee @hex{225F}
    let \lor \vee
    mathchardef \cap @hex{225C}
    mathchardef \cup @hex{225B}
    mathchardef \ddagger @hex{227A}
    mathchardef \dagger @hex{2279}
    mathchardef \sqcap @hex{2275}
    mathchardef \sqcup @hex{2274}
    mathchardef \uplus @hex{225D}
    mathchardef \amalg @hex{2271}
    mathchardef \diamond @hex{2205}
    mathchardef \bullet @hex{220F}
    mathchardef \wr @hex{226F}
    mathchardef \div @hex{2204}
    mathchardef \odot @hex{220C}
    mathchardef \oslash @hex{220B}
    mathchardef \otimes @hex{220A}
    mathchardef \ominus @hex{2209}
    mathchardef \oplus @hex{2208}
    mathchardef \mp @hex{2207}
    mathchardef \pm @hex{2206}
    mathchardef \circ @hex{220E}
    mathchardef \bigcirc @hex{220D}
    mathchardef \setminus @hex{226E}
    mathchardef \cdot @hex{2201}
    mathchardef \ast @hex{2203}
    mathchardef \times @hex{2202}
    mathchardef \star @hex{213F}
    mathchardef \propto @hex{322F}
    mathchardef \sqsubseteq @hex{3276}
    mathchardef \sqsupseteq @hex{3277}
    mathchardef \parallel @hex{326B}
    mathchardef \mid @hex{326A}
    mathchardef \dashv @hex{3261}
    mathchardef \vdash @hex{3260}
    mathchardef \nearrow @hex{3225}
    mathchardef \searrow @hex{3226}
    mathchardef \nwarrow @hex{322D}
    mathchardef \swarrow @hex{322E}
    mathchardef \Leftrightarrow @hex{322C}
    mathchardef \Leftarrow @hex{3228}
    mathchardef \Rightarrow @hex{3229}
    def \neq {not, =}
    let \ne \neq
    mathchardef \leq @hex{3214}
    let \le \leq
    mathchardef \geq @hex{3215}
    let \ge \geq
    mathchardef \succ @hex{321F}
    mathchardef \prec @hex{321E}
    mathchardef \approx @hex{3219}
    mathchardef \succeq @hex{3217}
    mathchardef \preceq @hex{3216}
    mathchardef \supset @hex{321B}
    mathchardef \subset @hex{321A}
    mathchardef \supseteq @hex{3213}
    mathchardef \subseteq @hex{3212}
    mathchardef \in @hex{3232}
    mathchardef \ni @hex{3233}
    let \owns \ni
    mathchardef \gg @hex{321D}
    mathchardef \ll @hex{321C}
    mathchardef not @hex{3236}
    let \not not
    mathchardef \leftrightarrow @hex{3224}
    mathchardef leftarrow @hex{3220}
    let \leftarrow leftarrow
    let \gets \leftarrow
    mathchardef rightarrow @hex{3221}
    let \rightarrow rightarrow
    let \to \rightarrow
    mathchardef mapstochar @hex{3237}
    def\mapsto {mapstochar, rightarrow}
    mathchardef \sim @hex{3218}
    mathchardef \simeq @hex{3227}
    mathchardef \perp @hex{323F}
    mathchardef \equiv @hex{3211}
    mathchardef \asymp @hex{3210}
    mathchardef \smile @hex{315E}
    mathchardef \frown @hex{315F}
    mathchardef \leftharpoonup @hex{3128}
    mathchardef \leftharpoondown @hex{3129}
    mathchardef \rightharpoonup @hex{312A}
    mathchardef \rightharpoondown @hex{312B}

    def joinrel {mathrel{mkern "-3mu"}}
    def \relbar {mathrel{smash "-"}} % \smash, because - has the same height as +
    def \Relbar {mathrel "="}
    mathchardef \lhook @hex{312C}
    def \hookrightarrow {\lhook; joinrel; \rightarrow}
    mathchardef \rhook @hex{312D}
    def \hookleftarrow {\leftarrow; joinrel; \rhook}
    def \bowtie {mathrel \triangleright; joinrel; mathrel \triangleleft}
    def \models {mathrel "|"; joinrel; "="}
    def \Longrightarrow {\Relbar; joinrel; \Rightarrow}
    def \longrightarrow {\relbar; joinrel; \rightarrow}
    def \longleftarrow {\leftarrow; joinrel; \relbar}
    def \Longleftarrow {\Leftarrow; joinrel; \Relbar}
    def \longmapsto {mapstochar; \longrightarrow}
    def \longleftrightarrow {\leftarrow; joinrel; \rightarrow}
    def \Longleftrightarrow {\Leftarrow; joinrel; \Rightarrow}
    def \iff {\; \Longleftrightarrow \;}
    def \implies {\Rightarrow}

    mathchardef ldotp @hex{613A} % ldot as a punctuation mark
    mathchardef cdotp @hex{6201} % cdot as a punctuation mark
    mathchardef \colon @hex{603A} % colon as a punctuation mark
    def\ldots {mathinner{ldotp; ldotp; ldotp}}
    def\cdots {mathinner{cdotp; cdotp; cdotp}}
    def\vdots {vbox{
        baselineskip 4pt; lineskiplimit zero
        kern 6pt; hbox{"."}; hbox{"."}; hbox{"."}
    }}
    def\ddots {mathinner{
        mkern "1mu"; raise 7pt vbox{kern 7pt; hbox{"."}}
        mkern "2mu"; raise 4pt hbox{"."}
        mkern "2mu"; raise 1pt hbox{"."}
        mkern "1mu"
    }}

    def \acute {mathaccent @hex{7013}}
    def \grave {mathaccent @hex{7012}}
    def \ddot {mathaccent @hex{707F}}
    def \tilde {mathaccent @hex{707E}}
    def \bar {mathaccent @hex{7016}}
    def \breve {mathaccent @hex{7015}}
    def \check {mathaccent @hex{7014}}
    def \hat {mathaccent @hex{705E}}
    def \vec {mathaccent @hex{017E}}
    def \dot {mathaccent @hex{705F}}
    def \widetilde {mathaccent @hex{0365}}
    def \widehat {mathaccent @hex{0362}}

    def \overrightarrow #1 {vbox{
        mathsurround.zero
        ialign{## crcr
            rightarrowfill; crcr
            noalign{kern -1pt; nointerlineskip}
            bmath; hfil; displaystyle; {#1}; hfil; emath; crcr
        }
    }}

    def \overleftarrow #1 {vbox{
        mathsurround.zero
        ialign{## crcr
            leftarrowfill; crcr
            noalign{kern -1pt; nointerlineskip}
            bmath; hfil; displaystyle; {#1}; hfil; emath; crcr
        }
    }}

    def \overbrace #1 {mathop{
        vbox{
            mathsurround.zero
            ialign{## crcr
                noalign{kern 3pt}
                downbracefill crcr
                noalign{kern 3pt; nointerlineskip}
                bmath; hfil; displaystyle{#1}; hfil; emath; crcr
        }}}
        limits
    }

    def \underbrace #1 {mathop{
        vtop{
            mathsurround.zero
            ialign{## crcr
                bmath; hfil; displaystyle{#1}; hfil; emath; crcr
                noalign{kern 3pt; nointerlineskip}
                upbracefill crcr
                noalign{kern 3pt}
        }}}
        limits
    }

    def \skew #1 #2 #3 {
        {
            muskip.tmp #1 "mu"
            divide muskip.tmp num_2
            mkern muskip.tmp
            #2 {mkern -muskip.tmp; {#3}; mkern muskip.tmp}
            mkern -muskip.tmp
        }
        {}
    }

    def \lmoustache {delimiter @hex{437A340}} % top from (, bottom from )
    def \rmoustache {delimiter @hex{537B341}} % top from ), bottom from (
    def \lgroup {delimiter @hex{462833A}} % extensible ( with sharper tips
    def \rgroup {delimiter @hex{562933B}} % extensible ) with sharper tips
    def \arrowvert {delimiter @hex{26A33C}} % arrow without arrowheads
    def \Arrowvert {delimiter @hex{26B33D}} % double arrow without arrowheads
    def \bracevert {delimiter @hex{77C33E}} % the vertical bar that extends braces
    def \Vert {delimiter @hex{26B30D}}
    let \| \Vert
    def \vert {delimiter @hex{26A30C}}
    def \uparrow {delimiter @hex{3222378}}
    def \downarrow {delimiter @hex{3223379}}
    def \updownarrow {delimiter @hex{326C33F}}
    def \Uparrow {delimiter @hex{322A37E}}
    def \Downarrow {delimiter @hex{322B37F}}
    def \Updownarrow {delimiter @hex{326D377}}
    def \backslash {delimiter @hex{26E30F}} % for double coset G\backslash H
    def \rangle {delimiter @hex{526930B}}
    def \langle {delimiter @hex{426830A}}
    def \rbrace {delimiter @hex{5267309}}
    let \} \rbrace
    def \lbrace {delimiter @hex{4266308}}
    let \{ \lbrace
    def \rceil {delimiter @hex{5265307}}
    def \lceil {delimiter @hex{4264306}}
    def \rfloor {delimiter @hex{5263305}}
    def \lfloor {delimiter @hex{4262304}}
    def \rceiling {\rceil}
    def \lceiling {\lceil}

    def \bigl {mathopen \big}
    def \bigm {mathrel \big}
    def \bigr {mathclose \big}
    def \Bigl {mathopen \Big}
    def \Bigm {mathrel \Big}
    def \Bigr {mathclose \Big}
    def \biggl {mathopen \bigg}
    def \biggm {mathrel \bigg}
    def \biggr {mathclose \bigg}
    def \Biggl {mathopen \Bigg}
    def \Biggm {mathrel \Bigg}
    def \Biggr {mathclose \Bigg}

    def \big #1 {big_1{"8.5"pt} #1}
    def \Big #1 {big_1{"11.5"pt} #1}
    def \bigg #1 {big_1{"14.5"pt} #1}
    def \Bigg #1 {big_1{"17.5"pt} #1}

    def big_1 #1 #2 {{hbox{
        bmath
            left #2; vbox to #1 {}; right "."
            nulldelimiterspace zero; mathsurround zero
        emath
    }}}

    def \choose {atopwithdelims "()"}
    def \brack {atopwithdelims "[]"}
    def \brace {atopwithdelims \{ \}}

    def sqrtsign {radical @hex{270370}}

    def mathpalette #1 #2 {
        mathchoice
            {#1 displaystyle, {#2}}
            {#1 textstyle, {#2}}
            {#1 scriptstyle, {#2}}
            {#1 scriptscriptstyle, {#2}}
    }

    newbox rootbox

    def \root #1 \of {
        setbox rootbox hbox{bmath
            mathsurround.zero; scriptscriptstyle{#1}
        emath }
        mathpalette root_1
    }


    def root_1 #1 #2 {
        setbox zero hbox{bmath
            mathsurround.zero; #1; \sqrt{#2}
        emath}
        dimen.tmp ht zero; advance dimen.tmp -dp zero
        mkern "5mu"
        raise ".6" dimen.tmp copy rootbox
        mkern "-10"mu
        box zero
    }

    def \sqrt {futurelet next sqrt}
    def sqrt {
        ifx '[ next
            let next_1 nsqrt
        else
            let next_1 sqrtsign
        fi
        next_1
    }
    def nsqrt '[ #1 '] {\root #1 \of}
    

    newif ifvphantom
    newif ifhphantom
    def \vphantom {vphantomtrue; hphantomfalse; phantom_1}
    def \hphantom {vphantomtrue; hphantomfalse; phantom_1}
    def \phantom {vphantomtrue; hphantomtrue; phantom_1}
    def phantom_1 {
        ifmmode
            def next {mathpalette phantom_math}%
        else
            let next phantom_2
        fi
        next
    }
    def phantom_2 #1 {setbox zero hbox{#1}; phantom_3}
    def phantom_math #1 #2 {
        setbox zero hbox{
            bmath; mathsurround.zero; #1 {#2}; emath
        }
        phantom_3
    }

    def phantom_3 {
        setbox num_2 null
        ifvphantom, ht num_2 ht zero; dp num_2 dp zero, fi
        ifhphantom, wd num_2 wd zero, fi
        box num_2
    }

    def mathstrut {\vphantom "("}
    let \mathstrut mathstrut
    def smash {
        relax % \relax, in case this comes first in \halign
        ifmmode
            def next{mathpalette smash_math}
        else
            let next smash_1
        fi
        next
    }
    let \smash smash
    def smash_1 #1 {setbox zero hbox{#1}; smash_2}
    def smash_math #1 #2 {
        setbox zero hbox{bmath; #1 {#2}; emath}
        smash_2
    }
    def smash_2{ht zero zero; dp zero zero; box zero}

    def \cong {mathrel{mathpalette overeq \sim}} % congruence sign

    def overeq #1#2 {
        lower ".5"pt vbox{
            lineskiplimit maxdimen
            lineskip "-.5"pt
            ialign{bmath; mathsurround.zero; #1; hfil ## hfil; emath; crcr
                #2; crcr
                "="; crcr
    }}}

    def \notin {mathrel{mathpalette cancel \in}}
    def cancel #1 #2 {
        mathsurround.zero; ooalign{
            bmath; hfil; #1; mkern "1mu"; "/"; emath; crcr
            bmath; #1; #2; emath
    }}

    def \rightleftharpoons {mathrel{mathpalette rightleftharpoons_1, {}}}
    def rightleftharpoons_1 #1 {vcenter{
        mathsurround.zero; hbox{ooalign{
            raise 2pt hbox{bmath; #1 \rightharpoonup; emath}; crcr
            bmath; #1 \leftharpoondown; emath; crcr
    }}}}

    def buildrel #1 over #2 {
        mathrel{mathop{kern zero; #2}; limits; sup {#1}}
    }
    def \doteq {buildrel textstyle "." \over "="}
    
    def \log {mathop{\rm "log"}, nolimits}
    def \lg {mathop{\rm "lg"}, nolimits}
    def \ln {mathop{\rm "ln"}, nolimits}
    def \lim {mathop{\rm "lim"}}
    def \limsup {mathop{\rm "lim" \, "sup"}}
    def \liminf {mathop{\rm "lim" \, "inf"}}
    def \sin {mathop{\rm "sin"}, nolimits}
    def \arcsin {mathop{\rm "arcsin"}, nolimits}
    def \sinh {mathop{\rm "sinh"}, nolimits}
    def \cos {mathop{\rm "cos"}, nolimits}
    def \arccos {mathop{\rm "arccos"}, nolimits}
    def \cosh {mathop{\rm "cosh"}, nolimits}
    def \tan {mathop{\rm "tan"}, nolimits}
    def \arctan {mathop{\rm "arctan"}, nolimits}
    def \tanh {mathop{\rm "tanh"}, nolimits}
    def \cot {mathop{\rm "cot"}, nolimits}
    def \coth {mathop{\rm "coth"}, nolimits}
    def \sec {mathop{\rm "sec"}, nolimits}
    def \csc {mathop{\rm "csc"}, nolimits}
    def \max {mathop{\rm "max"}}
    def \min {mathop{\rm "min"}}
    def \sup {mathop{\rm "sup"}}
    def \inf {mathop{\rm "inf"}}
    def \arg {mathop{\rm "arg"}, nolimits}
    def \ker {mathop{\rm "ker"}, nolimits}
    def \dim {mathop{\rm "dim"}, nolimits}
    def \hom {mathop{\rm "hom"}, nolimits}
    def \det {mathop{\rm "det"}}
    def \exp {mathop{\rm "exp"}, nolimits}
    def \Pr {mathop{\rm "Pr"}}
    def \gcd {mathop{\rm "gcd"}}
    def \deg {mathop{\rm "deg"}, nolimits}
    def \lcm {mathop{\rm "lcm"}}

    def \bmod {
        nonscript mskip -medmuskip
        mkern "5mu"
        mathbin{\rm "mod"}
        penalty 900; mkern "5mu"
        nonscript mskip -medmuskip
    }

    def \pmod #1 {
        allowbreak; mkern "18mu"
        "("; {\rm "mod"}; \,\, ; #1; ")"
    }

    def \cases #1 {
        left \{; \,
            vcenter{
                normalbaselines; mathsurround.zero
                ialign{bmath; ## hfil emath; align.tab; quad ##; hfil; crcr
                  #1; crcr
            }}
        right "."
    }

    def \matrix #1 {
        null; \,
        vcenter{normalbaselines; mathsurround.zero
            ialign{hfil; $##$; hfil &&
                quad; hfil; $##$; hfil; crcr
                mathstrut; crcr
                noalign{kern -baselineskip}
                #1; crcr
                mathstrut; crcr
                noalign{kern -baselineskip}
        }}
        \,
    }

    def \pmatrix #1 {left "("; \matrix{#1}; right ")"}

    newdimen paren.wd
    setbox zero hbox{cmex10 "B"}
    paren.wd wd zero            % Width of the big left (.

TODO: \endline.  Check this macro.
    def \bordermatrix #1 {
        begingroup; mathsurround.zero
            setbox zero vbox{
              def \cr{crcr; noalign{kern 2pt; global let \cr cr}}
              ialign{$##$ hfil kern 2pt kern paren.wd & \thinspace hfil$##$hfil
                &&quad hfil$##$ hfil crcr
                 omit strut hfil crcr
                noalign{kern -baselineskip}
                #1 crcr
                omit strut cr}}
            setbox num_2 vbox{unvcopy zero; global setbox num_1 lastbox}
            setbox num_2 hbox{unhbox num_1; unskip; global setbox num_1 lastbox}
            setbox num_2 hbox{bmath
                kern wd num_1; kern -paren.wd
                left "("
                    kern -wd num_1
                    global setbox num_1 vbox{box num_1; kern 2pt}
                    vcenter{kern -ht num_1; unvbox zero; kern -baselineskip}
                    \,
                right ")"
            emath}
            null; \;; vbox{kern ht num_1; box num_2}
        endgroup
    }

    def openup {afterassignment openup_1; dimen.tmp =}
    def openup_1{
        advance lineskip dimen.tmp; advance baselineskip dimen.tmp
        advance lineskiplimit dimen.tmp
    }
    def eqalign #1 {
        null ; \,; vcenter{
            openup jot; mathsurround.zero
            ialign{strut; hfil; bmath;displaystyle{##}; emath
                align.tab; bmath; displaystyle{{}##}; emath; hfill; crcr
                #1 crcr}}
        \,
    }
    let \eqalign eqalign


TODO: Review, test and revise the displayskip code.
    newif ifdisplaytop
    def display_1 {
        global displaytoptrue; openup jot; mathsurround.zero
        everycr{noalign{
            ifdisplaytop
                global displaytopfalse
                ifdim prevdepth > -1000pt
                    vskip -lineskiplimit; vskip normallineskiplimit
                fi
            else
                penalty interdisplaylinepenalty
            fi
        }}
    }

    def display_2{tabskip zero.skip; everycr{}} % restore inside \display_1

    def \displaylines #1 {
      display_1; tabskip zero.skip
      halign{hbox to displaywidth{
          $display_2; hfil; displaystyle ## hfil$} crcr
          #1 crcr
      }}

    def eqalignno #1 {
        display_1 \tabskip\centering
        halign to displaywidth{
          hfil$display_2 displaystyle{##}$ tabskip zero.skip
          &$display_2 displaystyle{{}##}$ hfil; tabskip centering
          &llap{$display_2##$}tabskip zero.skip crcr
          #1 crcr
    }}
    let \eqalignno eqalignno

  def leqalignno #1 {display_1; tabskip centering
      halign to displaywidth{hfil $display_2 displaystyle{##}$
          tabskip zero.skip
          &$display_2 displaystyle{{}##}$hfil tabskip centering
          &kern -displaywidth; rlap{$display_2n##$} tabskip displaywidth; crcr
          #1 crcr
    }}

7.  Macros for output.

The value of 'pageno' should be set to one each time the daemon is
called.
    countdef pageno 0
    newtoks headline
    headline { hfil}

    newtoks footline
    footline{hss; cmr10; folio; hss}
    newif ifraggedbottom

    def raggedbottom {topskip 10pt plus 60pt; raggedbottomtrue}
    def normalbottom {topskip 10pt; raggedbottomfalse}

    def folio {
        ifnum pageno < zero
            romannumeral -pageno
        else
            number pageno
        fi
    }
    def nopagenumbers {footline{hfil}}

    def advancepageno {
        ifnum pageno < zero
            global advance pageno minus_1
        else
            global advance pageno num_1
        fi
    }

    newinsert footins
    def footnote #1 {
        let restore.spacefactor empty
        ifhmode
            edef restore.spacefactor {spacefactor the spacefactor}
            ital_corr
        fi
        #1
        restore.spacefactor
        footnote_1{#1}
    }

    def footnote_1 #1 {
        insert footins bgroup
            interlinepenalty interfootnotelinepenalty
            splittopskip ht strutbox % top baseline for broken footnotes
            splitmaxdepth dp strutbox
            floatingpenalty num_20000
            leftskip zero.skip; rightskip zero.skip
            spaceskip zero.skip; xspaceskip zero.skip
            textindent{#1}
            footstrut
            futurelet next footnote_2
    }

    def footnote_2 {
          ifcat bgroup noexpand next
              let next footnote_3
          else
              let next footnote_4
          fi
          next
    }
    def footnote_3 {bgroup; aftergroup footnote_5; let next}
    def footnote_4 #1 {#1; footnote_5}
    def footnote_5 {strut egroup}
    def footstrut {vbox to splittopskip{}}
    skip footins bigskipamount
    count footins 1000
    dimen footins "8in "

    newinsert topins
    newif ifpage
    newif ifmid
    def topinsert{ midfalse pagefalse insert_1}
    def midinsert{ midtrue insert_1}
    def pageinsert{ midfalse pagetrue insert_1}
    skip topins zero.skip
    count topins 1000
    dimen topins maxdimen
    def insert_1 {
        par
        begingroup
            setbox zero vbox bgroup
    }

Command \endinsert might be insecure.
    def endinsert {
        egroup % finish the  vbox
        ifmid
            dimen.tmp ht zero
            advance dimen.tmp dp zero
            advance dimen.tmp 12pt
            advance dimen.tmp pagetotal
            advance dimen.tmp -pageshrink
            ifdim dimen.tmp > pagegoal
                midfalse; pagefalse
        fi fi
        ifmid
            bigskip; box zero; bigbreak
        else
            insert topins {
                penalty 100 % floating insertion
                splittopskip zero.skip
                splitmaxdepth maxdimen
                floatingpenalty zero
                ifpage
                    dimen.tmp dp zero
                    vbox to vsize {unvbox zero; kern -dimen.tmp}
                else
                    box zero; nobreak; bigskip
                fi
            }
        fi
        endgroup
    }

    output{plainoutput}
    def plainoutput {
        shipout vbox{makeheadline; pagebody; makefootline}
        advancepageno
        ifnum outputpenalty > -num_20000
        else dosupereject fi
    }
    def pagebody {vbox to vsize{boxmaxdepth maxdepth; pagecontents}}
    def makeheadline {
        vbox to zero {
            vskip "-22.5"pt
            line{ vbox to "8.5"pt{} the headline}
            vss
        }
        nointerlineskip
    }
    def makefootline {baselineskip 24pt; lineskiplimit zero; line{the footline}}
    def dosupereject {
        ifnum insertpenalties > zero
            line{}; kern -topskip; nobreak; vfill; supereject
        fi
    }

    def pagecontents {
        ifvoid topins else
            unvbox topins
        fi
        dimen.tmp dp num_255
        unvbox num_255
        ifvoid footins else
            vskip skip footins
            footnoterule
            unvbox footins
        fi
        ifraggedbottom  kern -dimen.tmp; vfil fi
    }

    def footnoterule { kern -3pt; hrule width "2truein"; kern "2.6"pt}

8.  Hyphenation and everything else.

We do not provide the plain commands \magnification and \loggingall.

    lefthyphenmin 2~
    righthyphenmin 3~

This is how we load hyphenation patterns.
    {
        let \patterns patterns
        let \hyphenation hyphenation
        catcode `\{ 1; catcode `\} 2
        input "hyphen "
    }

In plain, \tracingall also calls \errorstopmode.  But here, the
error-mode is for the \TeX daemon to control.
    def tracingall
    {
        tracingcommands num_2
        tracingstats num_2
        tracingpages num_1
        tracingoutput num_1
        tracinglostchars num_1
        tracingmacros num_1
        tracingparagraphs num_1
        tracingrestores num_1
        showboxbreadth maxdimen
        showboxdepth maxdimen
        tracingonline num_1
    }

    def \showhyphens #1
    {
        setbox 0 vbox {
            parfillskip zero.skip
            hsize maxdimen
            cmr10
            pretolerance minus_1
            tolerance minus_1
            hbadness 0
            showboxdepth 0
            ex_space #1
        }
    }

    normalbaselines
    nonfrenchspacing
    \rm

    def fmtname {"secplain"}
    def fmtversion {"0.02"}

    ]]
    \_dump
